#!/usr/bin/python3
# build a small initd world
from builder import BuilderBase
from threading import Thread
from time import sleep
import sys
import traceback

kbuild_make = [
	"make",
		"-C%(src_dir)s",
		"O=%(rout_dir)s",
		"KBUILD_HOST=builder",
		"KBUILD_USER=%(out_hash)s",
		"KBUILD_BUILD_TIMESTAMP=1970-01-01",
		"KBUILD_BUILD_VERSION=%(src_hash)s",
]

build_dir = "/tmp/builder"

linux = BuilderBase("linux",
	url = "https://cdn.kernel.org/pub/linux/kernel/v%(major)s.x/linux-%(version)s.tar.xz",
	version = "5.4.117",
	tarhash = "4e989b5775830092e5c76b5cca65ebff862ad0c87d0b58c3a20d415c3d4ec770",
	config_files = [ "config/linux-virtio.config" ],
	configure = [
		"make",
		"-C%(src_dir)s",
		"O=%(rout_dir)s",
		"olddefconfig"
	],
	make = kbuild_make,
)

busybox = BuilderBase("busybox",
	version = "1.32.0",
	url = "https://busybox.net/downloads/busybox-%(version)s.tar.bz2",
	tarhash = "c35d87f1d04b2b153d33c275c2632e40d388a88f19a9e71727e0bbbff51fe689",
	config_files = [ "config/busybox.config" ],
	configure = [
		"make",
		"-C%(src_dir)s",
		"O=%(rout_dir)s",
		"oldconfig"
	],
	make = kbuild_make,
)

util_linux = BuilderBase("util-linux",
	version		= "2.29.2",
	url		= "https://www.kernel.org/pub/linux/utils/util-linux/v%(major)s.%(minor)s/util-linux-%(version)s.tar.xz",
	tarhash		= "accea4d678209f97f634f40a93b7e9fcad5915d1f4749f6c47bee6bf110fe8e3",
	depends		= [ linux ],
	configure	= [
		"%(src_dir)s/configure",
		"--prefix", "/",
		"--oldincludedir", "%(linux.out_dir)s/include",
		"--without-ncurses",
		"--without-ncursesw",
		"--without-tinfo",
		"--without-python",
		"--without-udev",
		"--disable-bash-completion",
		"--disable-all-programs",
		"--enable-libuuid",
		"--enable-libblkid",
	],
	make = [ "make" ],
)

failed = False
build_count = 0

def build_thread(mod):
	global failed
	global build_count

	build_count += 1

	try:
		print(mod.name + ": building", file=sys.stderr)
		mod.build()
		print(mod.name + ": DONE!", file=sys.stderr)
	except Exception as e:
		print(mod.name + ": FAILED", file=sys.stderr)
		traceback.print_exception(e)
		failed = True

	build_count -= 1

# to build all, iterate over the list of buildable objects
# that have all of their dependencies met
def build_all(mods):
	global failed
	global build_count

	print("build_all(", [x.name for x in mods], ")")

	while len(mods) != 0 or build_count != 0:
		if failed:
			break

		if len(mods) == 0:
			# stuff is in process, wait for completions
			sleep(0.1)
			continue

		mod = mods.pop(0)
		#print(mod.name + " = pop(", [x.name for x in mods], ")")
		if mod.built:
			# someone else is already working on this one
			#print(mod.name + ": already built")
			continue
		if mod.building:
			# someone else is already working on this one
			#print(mod.name + ": in process")
			continue

		ready = True
		for dep in mod.depends:
			if dep.built:
				# we might be ready!
				continue
			elif dep.building:
				# someone else is working on it, so we wait
				#print(mod.name + ": wating on " + dep.name)
				ready = False
			else:
				#print(mod.name + ": need to build " + dep.name + " first")
				mods.insert(0, dep)
				ready = False

		if not ready:
			# put it back on the list for later
			#print(mod.name + ": not ready yet", mods)
			mods.append(mod)
			sleep(0.1)
			continue

		# it is time to build this mod
		mod.building = True
		Thread(target = build_thread, args=(mod,)).start()

build_all([util_linux, linux, busybox])
